2. 性能优化可以思考的途径：

a. 增加并行度---------可以理解为增加executor-cores，尤其是与kafka的partition数目相同为佳，可以并行读

b. 减少序列化/反序列化的负担-------用更优化的序列化方式Kryo

c. 设置合适的批处理时间间隔----因为作业之间存在先后关系，后一个作业必须等待前一个作业处理完成再开始；所以最好的实时处理的状态是，每一次批处理间隔都可以正好可以处理完成上一次时间间隔积累的数据；否则，则会造成后序作业的阻塞，不能满足实时的要求

d. 减小因任务提交和分发所带来的负担----据说standalone和coarse-gained mesos会比较好；但我们已经是确定用yarn提交任务了，所以此点不具备参考价值

3. 内存使用优化

a. 要确保内存至少能够满足能够容纳当前一次批处理作业的所有数据，否则就应该增加内存

b. 设置合适的spark.cleaner.ttl时长清理无用数据---需要小心设置以防止数据被超时错误清理；更合适的方式是将spark.streaming.unpersist设置为true，使得系统能够自动清理不再需要使用的RDD

c. 设置合适的GC策略

4. 作业的调度

我们对于Dstream的转换与操作，最终都会转换为操作链；但整个链并不会立即执行，它会在StreamingContext启动后执行。

Spark维护了一个周期定时器，每到一个时间间隔，就会产生一个作业；作业之间是有先后关系的，默认情况下一次运行一个，但也可以修改spark.streaming.concurrentJobs来配置并行的作业数目（这个参数可能还是存在一定风险的，如果作业存在写操作，那就可能需要考虑规避写冲突？）